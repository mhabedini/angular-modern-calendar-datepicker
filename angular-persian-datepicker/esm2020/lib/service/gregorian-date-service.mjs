import * as moment from 'moment';
import { getWeekFirstAndLastDays, processDateRange } from "../helper/date-helper";
import { extendMoment } from "moment-range";
export class GregorianDateService {
    constructor() {
        this.translate = {
            goToToday: 'Select today',
            nextMonth: 'Next',
            previousMonth: 'Prev',
        };
        this.config = {
            rtl: false,
            WeekendDays: [0, 6]
        };
        moment.locale('en');
    }
    months() {
        return moment.months();
    }
    monthsShort() {
        return moment.monthsShort();
    }
    weekdays() {
        return moment.weekdays();
    }
    weekdaysShort() {
        return moment.weekdaysShort().map(value => value.substring(0, 2));
    }
    daysInMonth(date) {
        date = moment(date);
        const month = date.month();
        const year = date.year();
        const startDate = moment([year, month, date.startOf('month').date()]);
        const endDate = moment([year, month, date.endOf('month').date()]);
        const [weeks, startDateDayBefore, endDateDayAfter] = processDateRange(startDate, endDate);
        const momentRange = extendMoment(moment);
        const calendar = [];
        const now = moment();
        weeks.forEach((week) => {
            let [firstWeekDay, lastWeekDay] = getWeekFirstAndLastDays(weeks, week, year);
            const weekRange = momentRange.range(firstWeekDay, lastWeekDay);
            const finalWeeks = [];
            Array.from(weekRange.by('day')).forEach((day, index) => {
                finalWeeks.push({
                    date: day,
                    gDate: day,
                    weekIndex: index,
                    day: day.date(),
                    isToday: day.isSame(now, "day"),
                    isForCurrentMonth: day.isBetween(startDateDayBefore, endDateDayAfter)
                });
            });
            calendar.push(finalWeeks);
        });
        return calendar;
    }
    getCurrentMonth(date) {
        return date.format('MMMM');
    }
    getCurrentYear(date) {
        return date.format('YYYY');
    }
    loadDaysInMonthWithYearAndMonth(year, month) {
        const date = moment([year, this.months().indexOf(month), 1]);
        return this.daysInMonth(date.format('YYYY/MM/DD'));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JlZ29yaWFuLWRhdGUtc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItcGVyc2lhbi1kYXRlcGlja2VyL3NyYy9saWIvc2VydmljZS9ncmVnb3JpYW4tZGF0ZS1zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sS0FBSyxNQUFNLE1BQU0sUUFBUSxDQUFBO0FBRWhDLE9BQU8sRUFBQyx1QkFBdUIsRUFBRSxnQkFBZ0IsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQ2hGLE9BQU8sRUFBQyxZQUFZLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFHMUMsTUFBTSxPQUFPLG9CQUFvQjtJQVkvQjtRQVhBLGNBQVMsR0FBRztZQUNWLFNBQVMsRUFBRSxjQUFjO1lBQ3pCLFNBQVMsRUFBRSxNQUFNO1lBQ2pCLGFBQWEsRUFBRSxNQUFNO1NBQ3RCLENBQUM7UUFFRixXQUFNLEdBQUc7WUFDUCxHQUFHLEVBQUUsS0FBSztZQUNWLFdBQVcsRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7U0FDcEIsQ0FBQTtRQUdDLE1BQU0sQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUE7SUFDckIsQ0FBQztJQUVELE1BQU07UUFDSixPQUFPLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQztJQUN6QixDQUFDO0lBRUQsV0FBVztRQUNULE9BQU8sTUFBTSxDQUFDLFdBQVcsRUFBRSxDQUFDO0lBQzlCLENBQUM7SUFFRCxRQUFRO1FBQ04sT0FBTyxNQUFNLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDM0IsQ0FBQztJQUVELGFBQWE7UUFDWCxPQUFPLE1BQU0sQ0FBQyxhQUFhLEVBQUUsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3BFLENBQUM7SUFFRCxXQUFXLENBQUMsSUFBUztRQUNuQixJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFBO1FBQ25CLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQTtRQUMxQixNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxFQUFFLENBQUE7UUFFeEIsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUMsQ0FBQTtRQUNyRSxNQUFNLE9BQU8sR0FBRyxNQUFNLENBQUMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFBO1FBRWpFLE1BQU0sQ0FBQyxLQUFLLEVBQUUsa0JBQWtCLEVBQUUsZUFBZSxDQUFDLEdBQUcsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxDQUFBO1FBRXpGLE1BQU0sV0FBVyxHQUFRLFlBQVksQ0FBQyxNQUFNLENBQUMsQ0FBQTtRQUM3QyxNQUFNLFFBQVEsR0FBVSxFQUFFLENBQUE7UUFDMUIsTUFBTSxHQUFHLEdBQUcsTUFBTSxFQUFFLENBQUE7UUFFcEIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQVMsRUFBRSxFQUFFO1lBQzFCLElBQUksQ0FBQyxZQUFZLEVBQUUsV0FBVyxDQUFDLEdBQUcsdUJBQXVCLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQTtZQUU1RSxNQUFNLFNBQVMsR0FBRyxXQUFXLENBQUMsS0FBSyxDQUFDLFlBQVksRUFBRSxXQUFXLENBQUMsQ0FBQTtZQUM5RCxNQUFNLFVBQVUsR0FBVSxFQUFFLENBQUE7WUFDNUIsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBUSxFQUFFLEtBQUssRUFBRSxFQUFFO2dCQUMxRCxVQUFVLENBQUMsSUFBSSxDQUFDO29CQUNkLElBQUksRUFBRSxHQUFHO29CQUNULEtBQUssRUFBRSxHQUFHO29CQUNWLFNBQVMsRUFBRSxLQUFLO29CQUNoQixHQUFHLEVBQUUsR0FBRyxDQUFDLElBQUksRUFBRTtvQkFDZixPQUFPLEVBQUUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDO29CQUMvQixpQkFBaUIsRUFBRSxHQUFHLENBQUMsU0FBUyxDQUFDLGtCQUFrQixFQUFFLGVBQWUsQ0FBQztpQkFDdEUsQ0FBQyxDQUFBO1lBQ0osQ0FBQyxDQUFDLENBQUE7WUFDRixRQUFRLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQzVCLENBQUMsQ0FBQyxDQUFBO1FBRUYsT0FBTyxRQUFRLENBQUE7SUFDakIsQ0FBQztJQUVELGVBQWUsQ0FBQyxJQUFTO1FBQ3ZCLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQTtJQUM1QixDQUFDO0lBRUQsY0FBYyxDQUFDLElBQVM7UUFDdEIsT0FBTyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFBO0lBQzVCLENBQUM7SUFFRCwrQkFBK0IsQ0FBQyxJQUFZLEVBQUUsS0FBYTtRQUN6RCxNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFBO1FBQzVELE9BQU8sSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUE7SUFDcEQsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgbW9tZW50IGZyb20gJ21vbWVudCdcclxuaW1wb3J0IHtEYXRlU2VydmljZUludGVyZmFjZX0gZnJvbSBcIi4vZGF0ZS1zZXJ2aWNlLWludGVyZmFjZVwiO1xyXG5pbXBvcnQge2dldFdlZWtGaXJzdEFuZExhc3REYXlzLCBwcm9jZXNzRGF0ZVJhbmdlfSBmcm9tIFwiLi4vaGVscGVyL2RhdGUtaGVscGVyXCI7XHJcbmltcG9ydCB7ZXh0ZW5kTW9tZW50fSBmcm9tIFwibW9tZW50LXJhbmdlXCI7XHJcblxyXG5cclxuZXhwb3J0IGNsYXNzIEdyZWdvcmlhbkRhdGVTZXJ2aWNlIGltcGxlbWVudHMgRGF0ZVNlcnZpY2VJbnRlcmZhY2Uge1xyXG4gIHRyYW5zbGF0ZSA9IHtcclxuICAgIGdvVG9Ub2RheTogJ1NlbGVjdCB0b2RheScsXHJcbiAgICBuZXh0TW9udGg6ICdOZXh0JyxcclxuICAgIHByZXZpb3VzTW9udGg6ICdQcmV2JyxcclxuICB9O1xyXG5cclxuICBjb25maWcgPSB7XHJcbiAgICBydGw6IGZhbHNlLFxyXG4gICAgV2Vla2VuZERheXM6IFswLCA2XVxyXG4gIH1cclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICBtb21lbnQubG9jYWxlKCdlbicpXHJcbiAgfVxyXG5cclxuICBtb250aHMoKTogc3RyaW5nW10ge1xyXG4gICAgcmV0dXJuIG1vbWVudC5tb250aHMoKTtcclxuICB9XHJcblxyXG4gIG1vbnRoc1Nob3J0KCk6IHN0cmluZ1tdIHtcclxuICAgIHJldHVybiBtb21lbnQubW9udGhzU2hvcnQoKTtcclxuICB9XHJcblxyXG4gIHdlZWtkYXlzKCk6IHN0cmluZ1tdIHtcclxuICAgIHJldHVybiBtb21lbnQud2Vla2RheXMoKTtcclxuICB9XHJcblxyXG4gIHdlZWtkYXlzU2hvcnQoKTogc3RyaW5nW10ge1xyXG4gICAgcmV0dXJuIG1vbWVudC53ZWVrZGF5c1Nob3J0KCkubWFwKHZhbHVlID0+IHZhbHVlLnN1YnN0cmluZygwLCAyKSk7XHJcbiAgfVxyXG5cclxuICBkYXlzSW5Nb250aChkYXRlOiBhbnkpOiBhbnlbXSB7XHJcbiAgICBkYXRlID0gbW9tZW50KGRhdGUpXHJcbiAgICBjb25zdCBtb250aCA9IGRhdGUubW9udGgoKVxyXG4gICAgY29uc3QgeWVhciA9IGRhdGUueWVhcigpXHJcblxyXG4gICAgY29uc3Qgc3RhcnREYXRlID0gbW9tZW50KFt5ZWFyLCBtb250aCwgZGF0ZS5zdGFydE9mKCdtb250aCcpLmRhdGUoKV0pXHJcbiAgICBjb25zdCBlbmREYXRlID0gbW9tZW50KFt5ZWFyLCBtb250aCwgZGF0ZS5lbmRPZignbW9udGgnKS5kYXRlKCldKVxyXG5cclxuICAgIGNvbnN0IFt3ZWVrcywgc3RhcnREYXRlRGF5QmVmb3JlLCBlbmREYXRlRGF5QWZ0ZXJdID0gcHJvY2Vzc0RhdGVSYW5nZShzdGFydERhdGUsIGVuZERhdGUpXHJcblxyXG4gICAgY29uc3QgbW9tZW50UmFuZ2U6IGFueSA9IGV4dGVuZE1vbWVudChtb21lbnQpXHJcbiAgICBjb25zdCBjYWxlbmRhcjogYW55W10gPSBbXVxyXG4gICAgY29uc3Qgbm93ID0gbW9tZW50KClcclxuXHJcbiAgICB3ZWVrcy5mb3JFYWNoKCh3ZWVrOiBhbnkpID0+IHtcclxuICAgICAgbGV0IFtmaXJzdFdlZWtEYXksIGxhc3RXZWVrRGF5XSA9IGdldFdlZWtGaXJzdEFuZExhc3REYXlzKHdlZWtzLCB3ZWVrLCB5ZWFyKVxyXG5cclxuICAgICAgY29uc3Qgd2Vla1JhbmdlID0gbW9tZW50UmFuZ2UucmFuZ2UoZmlyc3RXZWVrRGF5LCBsYXN0V2Vla0RheSlcclxuICAgICAgY29uc3QgZmluYWxXZWVrczogYW55W10gPSBbXVxyXG4gICAgICBBcnJheS5mcm9tKHdlZWtSYW5nZS5ieSgnZGF5JykpLmZvckVhY2goKGRheTogYW55LCBpbmRleCkgPT4ge1xyXG4gICAgICAgIGZpbmFsV2Vla3MucHVzaCh7XHJcbiAgICAgICAgICBkYXRlOiBkYXksXHJcbiAgICAgICAgICBnRGF0ZTogZGF5LFxyXG4gICAgICAgICAgd2Vla0luZGV4OiBpbmRleCxcclxuICAgICAgICAgIGRheTogZGF5LmRhdGUoKSxcclxuICAgICAgICAgIGlzVG9kYXk6IGRheS5pc1NhbWUobm93LCBcImRheVwiKSxcclxuICAgICAgICAgIGlzRm9yQ3VycmVudE1vbnRoOiBkYXkuaXNCZXR3ZWVuKHN0YXJ0RGF0ZURheUJlZm9yZSwgZW5kRGF0ZURheUFmdGVyKVxyXG4gICAgICAgIH0pXHJcbiAgICAgIH0pXHJcbiAgICAgIGNhbGVuZGFyLnB1c2goZmluYWxXZWVrcyk7XHJcbiAgICB9KVxyXG5cclxuICAgIHJldHVybiBjYWxlbmRhclxyXG4gIH1cclxuXHJcbiAgZ2V0Q3VycmVudE1vbnRoKGRhdGU6IGFueSk6IHN0cmluZyB7XHJcbiAgICByZXR1cm4gZGF0ZS5mb3JtYXQoJ01NTU0nKVxyXG4gIH1cclxuXHJcbiAgZ2V0Q3VycmVudFllYXIoZGF0ZTogYW55KTogc3RyaW5nIHtcclxuICAgIHJldHVybiBkYXRlLmZvcm1hdCgnWVlZWScpXHJcbiAgfVxyXG5cclxuICBsb2FkRGF5c0luTW9udGhXaXRoWWVhckFuZE1vbnRoKHllYXI6IG51bWJlciwgbW9udGg6IHN0cmluZyk6IGFueVtdIHtcclxuICAgIGNvbnN0IGRhdGUgPSBtb21lbnQoW3llYXIsIHRoaXMubW9udGhzKCkuaW5kZXhPZihtb250aCksIDFdKVxyXG4gICAgcmV0dXJuIHRoaXMuZGF5c0luTW9udGgoZGF0ZS5mb3JtYXQoJ1lZWVkvTU0vREQnKSlcclxuICB9XHJcbn1cclxuIl19